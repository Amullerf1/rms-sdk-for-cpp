<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>RMS SDK for C++: rmscore::modernapi::CustomProtectedStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RMS SDK for C++
   &#160;<span id="projectnumber">0.2.1</span>
   </div>
   <div id="projectbrief">A client library for using Microsoft RMS from Linux.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>rmscore</b></li><li class="navelem"><b>modernapi</b></li><li class="navelem"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html">CustomProtectedStream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classrmscore_1_1modernapi_1_1CustomProtectedStream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rmscore::modernapi::CustomProtectedStream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Used to access files that use a custom protection format.  
 <a href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CustomProtectedStream_8h_source.html">CustomProtectedStream.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rmscore::modernapi::CustomProtectedStream:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrmscore_1_1modernapi_1_1CustomProtectedStream.png" usemap="#rmscore::modernapi::CustomProtectedStream_map" alt=""/>
  <map id="rmscore::modernapi::CustomProtectedStream_map" name="rmscore::modernapi::CustomProtectedStream_map">
<area href="classrmscrypto_1_1api_1_1IStream.html" title="Base interface for protected streams. " alt="rmscrypto::api::IStream" shape="rect" coords="0,0,263,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af01bf567ba339b0bd281e2ea4e4bfa1b"><td class="memItemLeft" align="right" valign="top">virtual std::shared_future&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#af01bf567ba339b0bd281e2ea4e4bfa1b">ReadAsync</a> (uint8_t *pbBuffer, int64_t cbBuffer, int64_t cbOffset, std::launch launchType) override</td></tr>
<tr class="memdesc:af01bf567ba339b0bd281e2ea4e4bfa1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests contents of the stream to be read asynchronously into pbBuffer, and returns a std::shared_future to track status of the asynchronous operation. Call .get() or .wait() on this shared_future to synchronously await its completion.  <a href="#af01bf567ba339b0bd281e2ea4e4bfa1b">More...</a><br /></td></tr>
<tr class="separator:af01bf567ba339b0bd281e2ea4e4bfa1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4234d2725d6c2877c3317629aebc85"><td class="memItemLeft" align="right" valign="top">virtual std::shared_future&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#a9d4234d2725d6c2877c3317629aebc85">WriteAsync</a> (const uint8_t *cpbBuffer, int64_t cbBuffer, int64_t cbOffset, std::launch launchType) override</td></tr>
<tr class="memdesc:a9d4234d2725d6c2877c3317629aebc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that data from *cpbBuffer be written asynchronously to stream, and returns a std::shared_future to track status of the asynchronous operation. Call .get() or .wait() on this shared_future to synchronously await its completion.  <a href="#a9d4234d2725d6c2877c3317629aebc85">More...</a><br /></td></tr>
<tr class="separator:a9d4234d2725d6c2877c3317629aebc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2ae2c1ba2483fb92a7d1de2d0cb684"><td class="memItemLeft" align="right" valign="top">virtual std::future&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#aac2ae2c1ba2483fb92a7d1de2d0cb684">FlushAsync</a> (std::launch launchType) override</td></tr>
<tr class="memdesc:aac2ae2c1ba2483fb92a7d1de2d0cb684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that pending data be flushed asynchronously to stream, and returns a std::shared_future to track status of the asynchronous operation. Call .get() or .wait() on this shared_future to synchronously await its completion.  <a href="#aac2ae2c1ba2483fb92a7d1de2d0cb684">More...</a><br /></td></tr>
<tr class="separator:aac2ae2c1ba2483fb92a7d1de2d0cb684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07aad345aab1a2066377e9cb5536e13"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#ac07aad345aab1a2066377e9cb5536e13">Read</a> (uint8_t *pbBuffer, int64_t cbBuffer) override</td></tr>
<tr class="memdesc:ac07aad345aab1a2066377e9cb5536e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the backing stream.  <a href="#ac07aad345aab1a2066377e9cb5536e13">More...</a><br /></td></tr>
<tr class="separator:ac07aad345aab1a2066377e9cb5536e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9b03870b0dfdc149c925a56a0becd0"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#a8d9b03870b0dfdc149c925a56a0becd0">Write</a> (const uint8_t *cpbBuffer, int64_t cbBuffer) override</td></tr>
<tr class="memdesc:a8d9b03870b0dfdc149c925a56a0becd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the backing stream.  <a href="#a8d9b03870b0dfdc149c925a56a0becd0">More...</a><br /></td></tr>
<tr class="separator:a8d9b03870b0dfdc149c925a56a0becd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140ba77b40244e081b7ef9a0c506efb7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#a140ba77b40244e081b7ef9a0c506efb7">Flush</a> () override</td></tr>
<tr class="memdesc:a140ba77b40244e081b7ef9a0c506efb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the data to the backing stream.  <a href="#a140ba77b40244e081b7ef9a0c506efb7">More...</a><br /></td></tr>
<tr class="separator:a140ba77b40244e081b7ef9a0c506efb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee718905961e0d7b4203eb816fab3e19"><td class="memItemLeft" align="right" valign="top">virtual rmscrypto::api::SharedStream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#aee718905961e0d7b4203eb816fab3e19">Clone</a> () override</td></tr>
<tr class="memdesc:aee718905961e0d7b4203eb816fab3e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the <a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html" title="Used to access files that use a custom protection format. ">CustomProtectedStream</a>.  <a href="#aee718905961e0d7b4203eb816fab3e19">More...</a><br /></td></tr>
<tr class="separator:aee718905961e0d7b4203eb816fab3e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bff1f3ae943b3a2da764a9dcb78a85e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#a2bff1f3ae943b3a2da764a9dcb78a85e">Seek</a> (uint64_t u64Position) override</td></tr>
<tr class="memdesc:a2bff1f3ae943b3a2da764a9dcb78a85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current position to the specified offset in the stream.  <a href="#a2bff1f3ae943b3a2da764a9dcb78a85e">More...</a><br /></td></tr>
<tr class="separator:a2bff1f3ae943b3a2da764a9dcb78a85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d36a3c44e6bf437188962c975f5064b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#a5d36a3c44e6bf437188962c975f5064b">CanRead</a> () const override</td></tr>
<tr class="memdesc:a5d36a3c44e6bf437188962c975f5064b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value that indicates whether the file can be read from.  <a href="#a5d36a3c44e6bf437188962c975f5064b">More...</a><br /></td></tr>
<tr class="separator:a5d36a3c44e6bf437188962c975f5064b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f028e2a8c48f0b9f58920165c86c6b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#a35f028e2a8c48f0b9f58920165c86c6b">CanWrite</a> () const override</td></tr>
<tr class="memdesc:a35f028e2a8c48f0b9f58920165c86c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value that indicates whether the file can be written to.  <a href="#a35f028e2a8c48f0b9f58920165c86c6b">More...</a><br /></td></tr>
<tr class="separator:a35f028e2a8c48f0b9f58920165c86c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e093c88080552ef10c075e1f80dc8d1"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#a0e093c88080552ef10c075e1f80dc8d1">Position</a> () override</td></tr>
<tr class="memdesc:a0e093c88080552ef10c075e1f80dc8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current file seek offset.  <a href="#a0e093c88080552ef10c075e1f80dc8d1">More...</a><br /></td></tr>
<tr class="separator:a0e093c88080552ef10c075e1f80dc8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f385de0dabc1e9743e2369b9da2876"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#a15f385de0dabc1e9743e2369b9da2876">Size</a> () override</td></tr>
<tr class="memdesc:a15f385de0dabc1e9743e2369b9da2876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the protected data in bytes.  <a href="#a15f385de0dabc1e9743e2369b9da2876">More...</a><br /></td></tr>
<tr class="separator:a15f385de0dabc1e9743e2369b9da2876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af252d779952763b9b750937d6cb9e82e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#af252d779952763b9b750937d6cb9e82e">Size</a> (uint64_t u64Value) override</td></tr>
<tr class="memdesc:af252d779952763b9b750937d6cb9e82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the protected data in bytes.  <a href="#af252d779952763b9b750937d6cb9e82e">More...</a><br /></td></tr>
<tr class="separator:af252d779952763b9b750937d6cb9e82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrmscrypto_1_1api_1_1IStream"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrmscrypto_1_1api_1_1IStream')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a></td></tr>
<tr class="memitem:ad568299100aaed09c895ae079060596a inherit pub_methods_classrmscrypto_1_1api_1_1IStream"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad568299100aaed09c895ae079060596a"></a>
virtual std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Read</b> (uint64_t u64size)</td></tr>
<tr class="separator:ad568299100aaed09c895ae079060596a inherit pub_methods_classrmscrypto_1_1api_1_1IStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab184ba8857580063f1b327aeff99c940"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html">CustomProtectedStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#ab184ba8857580063f1b327aeff99c940">Create</a> (std::shared_ptr&lt; <a class="el" href="classrmscore_1_1modernapi_1_1UserPolicy.html">UserPolicy</a> &gt; policy, rmscrypto::api::SharedStream stream, uint64_t contentStartPosition, uint64_t contentSize)</td></tr>
<tr class="memdesc:ab184ba8857580063f1b327aeff99c940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html" title="Used to access files that use a custom protection format. ">CustomProtectedStream</a> object based on the specified protection policy and a backing stream.  <a href="#ab184ba8857580063f1b327aeff99c940">More...</a><br /></td></tr>
<tr class="separator:ab184ba8857580063f1b327aeff99c940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4cf37dbc84d6443550c600680bf461"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html#aaa4cf37dbc84d6443550c600680bf461">GetEncryptedContentLength</a> (std::shared_ptr&lt; <a class="el" href="classrmscore_1_1modernapi_1_1UserPolicy.html">UserPolicy</a> &gt;policy, uint64_t contentLength)</td></tr>
<tr class="memdesc:aaa4cf37dbc84d6443550c600680bf461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the length of the encrypted content from the length of the plaintext content.  <a href="#aaa4cf37dbc84d6443550c600680bf461">More...</a><br /></td></tr>
<tr class="separator:aaa4cf37dbc84d6443550c600680bf461"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a86f6aa3d7f2a041e849390ec6fb18a63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86f6aa3d7f2a041e849390ec6fb18a63"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CustomProtectedStream</b> (std::shared_ptr&lt; <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">IStream</a> &gt;pImpl)</td></tr>
<tr class="separator:a86f6aa3d7f2a041e849390ec6fb18a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1c4c51d5bfd91dc3c7365dac54125c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e1c4c51d5bfd91dc3c7365dac54125c"></a>
std::shared_ptr&lt; <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">IStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetImpl</b> ()</td></tr>
<tr class="separator:a7e1c4c51d5bfd91dc3c7365dac54125c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Used to access files that use a custom protection format. </p>
<p><b>Important</b> - RMS applications that use <a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html" title="Used to access files that use a custom protection format. ">CustomProtectedStream</a> may be incompatible with SharePoint, Exchange, and other RMS applications. For most applications, it is recommended that you use <a class="el" href="classrmscore_1_1modernapi_1_1ProtectedFileStream.html" title="Wraps a std::iostream to provide transparent encryption and decryption on read and write...">ProtectedFileStream</a> instead. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5d36a3c44e6bf437188962c975f5064b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rmscore::modernapi::CustomProtectedStream::CanRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value that indicates whether the file can be read from. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the file can be read from; otherwise false. </dd></dl>

<p>Implements <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a>.</p>

</div>
</div>
<a class="anchor" id="a35f028e2a8c48f0b9f58920165c86c6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rmscore::modernapi::CustomProtectedStream::CanWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value that indicates whether the file can be written to. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the file can be written to; otherwise false. </dd></dl>

<p>Implements <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a>.</p>

</div>
</div>
<a class="anchor" id="aee718905961e0d7b4203eb816fab3e19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SharedStream rmscore::modernapi::CustomProtectedStream::Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the <a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html" title="Used to access files that use a custom protection format. ">CustomProtectedStream</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html" title="Used to access files that use a custom protection format. ">CustomProtectedStream</a> object that represents the new stream. The initial seek position of the stream is 0. The seek position and lifetime of the new stream are independent of the position and lifetime of the original stream. </dd></dl>

<p>Implements <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a>.</p>

</div>
</div>
<a class="anchor" id="ab184ba8857580063f1b327aeff99c940"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html">CustomProtectedStream</a> &gt; rmscore::modernapi::CustomProtectedStream::Create </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrmscore_1_1modernapi_1_1UserPolicy.html">UserPolicy</a> &gt;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmscrypto::api::SharedStream&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>contentStartPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>contentSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html" title="Used to access files that use a custom protection format. ">CustomProtectedStream</a> object based on the specified protection policy and a backing stream. </p>
<p>The <a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html" title="Used to access files that use a custom protection format. ">CustomProtectedStream</a> can be used for both encrypting and decrypting content. If the backing stream already contains encrypted content, you can use the stream Read* methods to decrypt and read it. You can also use stream Write* methods to encrypt and write content to the backing stream.</p>
<p><b>Warning</b> - To avoid data loss and/or corruption, the Flush* methods must be called if you modify the created stream before the stream goes out of scope or is manually disposed.</p>
<p><b>Warning</b> - This method must be called on a UI thread. Calling it on a worker thread may result in an unexpected behavior.</p>
<dl class="section remark"><dt>Remarks</dt><dd>You must specify a range (contentStartPosition, contentSize) where the encrypted content is located in the backing stream. If there is no existing content in the backing stream (e.g. a new file), specify contentSize as 0. If the existing content ends at the end of the stream, you can specify ulong.MaxValue for contentSize. The contentSize parameter is needed only for those cases where there is non-encrypted app-specific content <em>after</em> the encrypted content; in this case the method needs to know where the encrypted content ends when performing decryption. The contentSize parameter is specified in terms of the encrypted content. For example, it should include the size of the CBC padding. If the range defined by the parameters contentStartPosition and contentSize is not empty (i.e. contentSize != 0), it must address an entire segment of encrypted content; that is, it must start from block 0 and must have a final block (for CBC) or be 16-byte aligned (for ECB).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The user policy to apply to protect the content. </td></tr>
    <tr><td class="paramname">stream</td><td>The backing stream. </td></tr>
    <tr><td class="paramname">contentStartPosition</td><td>The start position of encrypted content within the stream. </td></tr>
    <tr><td class="paramname">contentSize</td><td>The size of the encrypted content within the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classrmscore_1_1modernapi_1_1CustomProtectedStream.html" title="Used to access files that use a custom protection format. ">CustomProtectedStream</a> object that can be used to write content to the encrypted portion of the backing stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a140ba77b40244e081b7ef9a0c506efb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rmscore::modernapi::CustomProtectedStream::Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flushes the data to the backing stream. </p>
<dl class="section return"><dt>Returns</dt><dd>The result of the flush operation. True if data was successfully flushed; otherwise False. </dd></dl>

<p>Implements <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a>.</p>

</div>
</div>
<a class="anchor" id="aac2ae2c1ba2483fb92a7d1de2d0cb684"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; bool &gt; rmscore::modernapi::CustomProtectedStream::FlushAsync </td>
          <td>(</td>
          <td class="paramtype">std::launch&#160;</td>
          <td class="paramname"><em>launchType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that pending data be flushed asynchronously to stream, and returns a std::shared_future to track status of the asynchronous operation. Call .get() or .wait() on this shared_future to synchronously await its completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">launchType</td><td>Can be std::launch::async and/or std::launch::deferred. If deferred, flush will take place "lazily" - i.e. only when get() or wait() is called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(Future of) the result of the flush operation. True if data was successfully flushed; otherwise False. </dd></dl>

<p>Implements <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a>.</p>

</div>
</div>
<a class="anchor" id="aaa4cf37dbc84d6443550c600680bf461"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rmscore::modernapi::CustomProtectedStream::GetEncryptedContentLength </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrmscore_1_1modernapi_1_1UserPolicy.html">UserPolicy</a> &gt;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>contentLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the length of the encrypted content from the length of the plaintext content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>Pointer to userPolicy object. </td></tr>
    <tr><td class="paramname">contentLenght</td><td>Length of the plaintext content. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The encrypted content length. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e093c88080552ef10c075e1f80dc8d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rmscore::modernapi::CustomProtectedStream::Position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current file seek offset. </p>
<dl class="section return"><dt>Returns</dt><dd>The current file seek offset. </dd></dl>

<p>Implements <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a>.</p>

</div>
</div>
<a class="anchor" id="ac07aad345aab1a2066377e9cb5536e13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t rmscore::modernapi::CustomProtectedStream::Read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>cbBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from the backing stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbBuffer</td><td>The buffer into which the read operation puts the bytes that are read. </td></tr>
    <tr><td class="paramname">cbBuffer</td><td>The number of bytes available in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually read. </dd></dl>

<p>Implements <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a>.</p>

</div>
</div>
<a class="anchor" id="af01bf567ba339b0bd281e2ea4e4bfa1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_future&lt; int64_t &gt; rmscore::modernapi::CustomProtectedStream::ReadAsync </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>cbBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>cbOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::launch&#160;</td>
          <td class="paramname"><em>launchType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests contents of the stream to be read asynchronously into pbBuffer, and returns a std::shared_future to track status of the asynchronous operation. Call .get() or .wait() on this shared_future to synchronously await its completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbBuffer</td><td>The buffer into which the (asynchronous) read operation should place read bytes. </td></tr>
    <tr><td class="paramname">cbBuffer</td><td>Count of bytes in this buffer. </td></tr>
    <tr><td class="paramname">cbOffset</td><td>Offset into the buffer where bytes should begin being written. </td></tr>
    <tr><td class="paramname">launchType</td><td>Can be std::launch::async and/or std::launch::deferred. If deferred, read will take place "lazily" - i.e. only when get() or wait() is called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(Future of) count of bytes read. </dd></dl>

<p>Implements <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a>.</p>

</div>
</div>
<a class="anchor" id="a2bff1f3ae943b3a2da764a9dcb78a85e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rmscore::modernapi::CustomProtectedStream::Seek </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>u64Position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current position to the specified offset in the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u64Position</td><td>The offset in the stream to move to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a>.</p>

</div>
</div>
<a class="anchor" id="a15f385de0dabc1e9743e2369b9da2876"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rmscore::modernapi::CustomProtectedStream::Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the protected data in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of the protected data in bytes. </dd></dl>

<p>Implements <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a>.</p>

</div>
</div>
<a class="anchor" id="af252d779952763b9b750937d6cb9e82e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rmscore::modernapi::CustomProtectedStream::Size </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>u64Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the size of the protected data in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u64Value</td><td>Size of the protected data in bytes. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a>.</p>

</div>
</div>
<a class="anchor" id="a8d9b03870b0dfdc149c925a56a0becd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t rmscore::modernapi::CustomProtectedStream::Write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>cpbBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>cbBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to the backing stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpbBuffer</td><td>The buffer from which the write operation reads data to be written. </td></tr>
    <tr><td class="paramname">cbBuffer</td><td>The size of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written. </dd></dl>

<p>Implements <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a>.</p>

</div>
</div>
<a class="anchor" id="a9d4234d2725d6c2877c3317629aebc85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_future&lt; int64_t &gt; rmscore::modernapi::CustomProtectedStream::WriteAsync </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>cpbBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>cbBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>cbOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::launch&#160;</td>
          <td class="paramname"><em>launchType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that data from *cpbBuffer be written asynchronously to stream, and returns a std::shared_future to track status of the asynchronous operation. Call .get() or .wait() on this shared_future to synchronously await its completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpbBuffer</td><td>Pointer to the buffer from which the write operation will read contents to be written. </td></tr>
    <tr><td class="paramname">cbBuffer</td><td>Count of bytes in cpbBuffer. </td></tr>
    <tr><td class="paramname">cbOffset</td><td>Offset into cpbBuffer where operation will begin reading from for write. </td></tr>
    <tr><td class="paramname">launchType</td><td>Can be std::launch::async and/or std::launch::deferred. If deferred, write will take place "lazily" - i.e. only when get() or wait() is called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(Future of) count of bytes written. </dd></dl>

<p>Implements <a class="el" href="classrmscrypto_1_1api_1_1IStream.html">rmscrypto::api::IStream</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sdk/rms_sdk/ModernAPI/<a class="el" href="CustomProtectedStream_8h_source.html">CustomProtectedStream.h</a></li>
<li>sdk/rms_sdk/ModernAPI/CustomProtectedStream.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 27 2015 15:06:46 for RMS SDK for C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
